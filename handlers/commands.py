from itertools import groupby
from datetime import datetime
from pathlib import Path
import sys

from aiogram import Router
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.enums import ParseMode

from sqlalchemy import select

from db import get_sessionmaker
from models import User, TimetableEvent
from keyboards import paginated_kb
from utils.time import today_kiev, now_kiev
from utils.formatting import EntityBuilder

from repositories import (
    list_distinct_teachers,
    set_zoom_link,
    zoom_for_event,
)

router = Router(name="commands")

# ---------- HELP ----------
DEFAULT_HELP_TEXT = (
    "–ö–†–ù–£ –†–æ–∑–∫–ª–∞–¥ ‚Äî –¥–æ–≤—ñ–¥–∫–∞\n\n"
    "–ö–æ–º–∞–Ω–¥–∏: /start, /today, /tomorrow, /week, /next, /help\n"
    "–ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –æ–±–∏—Ä–∞—é—Ç—å—Å—è –≤ /start (1/5/10 —Ö–≤)."
)

def _read_help_md() -> str:
    candidates: list[Path] = []

    # 1) –ü–æ—Ä—É—á —ñ–∑ –≤–∏–∫–æ–Ω—É–≤–∞–Ω–∏–º —Ñ–∞–π–ª–æ–º (exe / onedir)
    if getattr(sys, "frozen", False):
        candidates.append(Path(sys.executable).parent / "help.md")

    # 2) –ó–∞–ø—É—Å–∫ —ñ–∑ —Å–æ—Ä—Å—ñ–≤: —à—É–∫–∞—î–º–æ help.md —É –±–∞—Ç—å–∫—ñ–≤—Å—å–∫–∏—Ö —Ç–µ–∫–∞—Ö (–¥–æ 3 —Ä—ñ–≤–Ω—ñ–≤)
    here = Path(__file__).resolve()
    for _ in range(3):
        here = here.parent
        candidates.append(here / "help.md")

    # 3) (–æ–ø—Ü—ñ–π–Ω–æ) PyInstaller onefile MEIPASS
    meipass = getattr(sys, "_MEIPASS", None)
    if meipass:
        candidates.append(Path(meipass) / "help.md")

    for p in candidates:
        try:
            return p.read_text(encoding="utf-8")
        except Exception:
            continue
    return DEFAULT_HELP_TEXT

@router.message(Command("help"))
async def help_cmd(message: Message):
    text = _read_help_md()
    try:
        await message.answer(text, parse_mode=ParseMode.MARKDOWN)  # legacy MD ‚Äî –±–µ–∑ —Å—Ç—Ä–æ–≥–æ–≥–æ –µ–∫—Ä–∞–Ω—É–≤–∞–Ω–Ω—è
    except Exception:
        await message.answer(text)

# ---------- —É—Ç–∏–ª—ñ—Ç–∏ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è ----------
def _subject_display(e: TimetableEvent) -> str:
    """
    "–ê–ë–†–ï–í–Ü–ê–¢–£–†–ê –ü–æ–≤–Ω–∞ –Ω–∞–∑–≤–∞" —è–∫—â–æ —î –æ–±–∏–¥–≤–∞, —ñ–Ω–∞–∫—à–µ —Ç–µ, —â–æ —î.
    """
    code = (e.subject_code or "").strip()
    full = (e.subject_full or "").strip()
    if code and full:
        return f"{code} {full}"
    return full or code or "–ü—Ä–µ–¥–º–µ—Ç"

def _teacher_display(e: TimetableEvent) -> str | None:
    """
    –ü–æ–≤–µ—Ä—Ç–∞—î –ü–Ü–ë –≤–∏–∫–ª–∞–¥–∞—á–∞ –ø–æ–≤–Ω—ñ—Å—Ç—é, –∞ —è–∫—â–æ –π–æ–≥–æ –Ω–µ–º–∞—î ‚Äî —Å–∫–æ—Ä–æ—á–µ–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç.
    """
    return (e.teacher_full or e.teacher_short or "").strip() or None

# ---------- –î–æ–±–æ–≤—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ ----------
async def _send_day(message: Message, day_offset: int):
    sm = get_sessionmaker()
    async with sm() as s:
        u = await s.scalar(select(User).where(User.user_id == message.from_user.id))
        if not u or not u.group_id:
            await message.answer("–ù–µ–º–∞—î –≥—Ä—É–ø–∏. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /start.")
            return
        from datetime import timedelta
        target = today_kiev().date() + timedelta(days=day_offset)
        rows = list((await s.execute(
            select(TimetableEvent).where(
                (TimetableEvent.group_id == u.group_id) &
                (TimetableEvent.date == target)
            ).order_by(TimetableEvent.time_start, TimetableEvent.lesson_number)
        )).scalars())

        if not rows:
            when = "—Å—å–æ–≥–æ–¥–Ω—ñ" if day_offset == 0 else "–∑–∞–≤—Ç—Ä–∞" if day_offset == 1 else str(target)
            await message.answer(f"–ü–∞—Ä–∏ {when} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ.")
            return

        b = EntityBuilder()
        b.add(f"–†–æ–∑–∫–ª–∞–¥ –Ω–∞ {target.strftime('%d.%m.%Y')}:\n")
        for e in rows:
            t = (
                f"{e.time_start.strftime('%H:%M')}-{e.time_end.strftime('%H:%M')}"
                if e.time_start and e.time_end else
                f"–ü–∞—Ä–∞ ‚Ññ{e.lesson_number}"
            )
            subj = _subject_display(e)
            lt = f" ({e.lesson_type})" if e.lesson_type else ""
            room = f", –∞—É–¥. {e.auditory}" if e.auditory else ""
            teacher = _teacher_display(e)
            teach = f"\n–í–∏–∫–ª.: {teacher}" if teacher else ""
            zoom = await zoom_for_event(s, e)
            zoom_line = f"\nZoom: {zoom}" if zoom else ""
            b.add(f"‚Ä¢ {t} ‚Äî ").add_bold(subj).add(f"{lt}{room}{teach}{zoom_line}").newline()

    text, entities = b.build()
    await message.answer(text, entities=entities)

@router.message(Command("today"))
async def today(message: Message):
    await _send_day(message, 0)

@router.message(Command("tomorrow"))
async def tomorrow(message: Message):
    await _send_day(message, 1)

@router.message(Command("week", "7days"))
async def week(message: Message):
    sm = get_sessionmaker()
    async with sm() as s:
        u = await s.scalar(select(User).where(User.user_id == message.from_user.id))
        if not u or not u.group_id:
            await message.answer("–ù–µ–º–∞—î –≥—Ä—É–ø–∏. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /start.")
            return

        from datetime import timedelta
        start = today_kiev().date()
        end = start + timedelta(days=6)

        rows = list((await s.execute(
            select(TimetableEvent).where(
                (TimetableEvent.group_id == u.group_id) &
                (TimetableEvent.date >= start) &
                (TimetableEvent.date <= end)
            ).order_by(TimetableEvent.date, TimetableEvent.time_start, TimetableEvent.lesson_number)
        )).scalars())

        if not rows:
            await message.answer(f"–ü–∞—Ä–∏ –∑ {start.strftime('%d.%m.%Y')} –ø–æ {end.strftime('%d.%m.%Y')} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ.")
            return

        b = EntityBuilder()
        b.add(f"–†–æ–∑–∫–ª–∞–¥ –Ω–∞ {start.strftime('%d.%m.%Y')}‚Äì{end.strftime('%d.%m.%Y')}:\n")

        for day, day_events_iter in groupby(rows, key=lambda e: e.date):
            day_events = list(day_events_iter)
            b.add(f"\nüìÖ {day.strftime('%d.%m.%Y')}\n")
            for e in day_events:
                t = (
                    f"{e.time_start.strftime('%H:%M')}-{e.time_end.strftime('%H:%M')}"
                    if e.time_start and e.time_end else
                    f"–ü–∞—Ä–∞ ‚Ññ{e.lesson_number}"
                )
                subj = _subject_display(e)
                lt = f" ({e.lesson_type})" if e.lesson_type else ""
                room = f", –∞—É–¥. {e.auditory}" if e.auditory else ""
                teacher = _teacher_display(e)
                teach = f"\n   –í–∏–∫–ª.: {teacher}" if teacher else ""
                zoom = await zoom_for_event(s, e)
                zoom_line = f"\n   Zoom: {zoom}" if zoom else ""
                b.add(f"‚Ä¢ {t} ‚Äî ").add_bold(subj).add(f"{lt}{room}{teach}{zoom_line}").newline()

    text, entities = b.build()
    await message.answer(text, entities=entities)

# ---------- –ù–∞–π–±–ª–∏–∂—á–∞ –ø–∞—Ä–∞ ----------
@router.message(Command("next"))
async def next_lesson(message: Message):
    """–ü–æ–∫–∞–∑–∞—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á—É –ø–∞—Ä—É –≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —á–∞—Å—É (–ö–∏—ó–≤). –Ø–∫—â–æ —Å—å–æ–≥–æ–¥–Ω—ñ –≤—Å–µ –º–∏–Ω—É–ª–æ ‚Äî –ø–µ—Ä—à—É –≤ –º–∞–π–±—É—Ç–Ω—ñ –¥–Ω—ñ."""
    sm = get_sessionmaker()
    now_local = now_kiev()
    today = now_local.date()
    current_time = now_local.time()

    async with sm() as s:
        u = await s.scalar(select(User).where(User.user_id == message.from_user.id))
        if not u or not u.group_id:
            await message.answer("–ù–µ–º–∞—î –≥—Ä—É–ø–∏. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /start.")
            return

        rows_today = list((await s.execute(
            select(TimetableEvent).where(
                (TimetableEvent.group_id == u.group_id) & (TimetableEvent.date == today)
            ).order_by(TimetableEvent.time_start, TimetableEvent.lesson_number)
        )).scalars())

        def is_future(ev: TimetableEvent) -> bool:
            if ev.time_start:
                return ev.time_start >= current_time
            return False

        next_ev = next((e for e in rows_today if is_future(e)), None)
        if not next_ev:
            rows_future = list((await s.execute(
                select(TimetableEvent).where(
                    (TimetableEvent.group_id == u.group_id) & (TimetableEvent.date > today)
                ).order_by(TimetableEvent.date, TimetableEvent.time_start, TimetableEvent.lesson_number)
            )).scalars())
            if rows_future:
                next_ev = rows_future[0]

        if not next_ev:
            await message.answer("–ù–∞–π–±–ª–∏–∂—á–∏—Ö –ø–∞—Ä –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")
            return

        b = EntityBuilder()
        date_str = next_ev.date.strftime('%d.%m.%Y')
        t = (
            f"{next_ev.time_start.strftime('%H:%M')}-{next_ev.time_end.strftime('%H:%M')}"
            if next_ev.time_start and next_ev.time_end else
            f"–ü–∞—Ä–∞ ‚Ññ{next_ev.lesson_number}"
        )
        subj = _subject_display(next_ev)
        lt = f" ({next_ev.lesson_type})" if next_ev.lesson_type else ""
        room = f", –∞—É–¥. {next_ev.auditory}" if next_ev.auditory else ""
        teacher = _teacher_display(next_ev)
        teach = f"\n–í–∏–∫–ª.: {teacher}" if teacher else ""
        zoom = await zoom_for_event(s, next_ev)
        zoom_line = f"\nZoom: {zoom}" if zoom else ""

        b.add(f"–ù–∞–π–±–ª–∏–∂—á–∞ –ø–∞—Ä–∞ ‚Äî {date_str}\n")
        b.add(f"{t} ‚Äî ").add_bold(subj).add(f"{lt}{room}{teach}{zoom_line}")

    text, entities = b.build()
    await message.answer(text, entities=entities)

# ---------- –ê–¥–º—ñ–Ω-–∫–æ–º–∞–Ω–¥–∞: –¥–æ–¥–∞—Ç–∏/–æ–Ω–æ–≤–∏—Ç–∏ Zoom –≤–∏–∫–ª–∞–¥–∞—á–∞ ----------
class ZoomAdd(StatesGroup):
    teacher = State()
    link = State()

@router.message(Command("addzoom", "setzoom"))
async def addzoom_entry(message: Message, state: FSMContext):
    """–ê–¥–º—ñ–Ω-–∫–æ–º–∞–Ω–¥–∞: –≤–∏–±—ñ—Ä –≤–∏–∫–ª–∞–¥–∞—á–∞ –∑—ñ —Å–ø–∏—Å–∫—É."""
    sm = get_sessionmaker()
    async with sm() as s:
        names = await list_distinct_teachers(s)
    if not names:
        await message.answer("–£ –±–∞–∑—ñ –ø–æ–∫–∏ –Ω–µ–º–∞—î –∂–æ–¥–Ω–æ–≥–æ –≤–∏–∫–ª–∞–¥–∞—á–∞ (—Å–ø–µ—Ä—à—É —ñ–º–ø–æ—Ä—Ç—É–π—Ç–µ —Ä–æ–∑–∫–ª–∞–¥).")
        return

    await state.update_data(teacher_names=names, page=0)
    kb = paginated_kb([(str(i), n) for i, n in enumerate(names)], page=0, per_page=10, prefix="tz")
    await message.answer("–û–±–µ—Ä—ñ—Ç—å –≤–∏–∫–ª–∞–¥–∞—á–∞:", reply_markup=kb)
    await state.set_state(ZoomAdd.teacher)

@router.callback_query(ZoomAdd.teacher)
async def addzoom_pick_teacher(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    names = data.get("teacher_names", [])
    page = data.get("page", 0)
    payload = cb.data

    if payload == "tz:__prev__":
        page = max(0, page - 1)
        await state.update_data(page=page)
        kb = paginated_kb([(str(i), n) for i, n in enumerate(names)], page=page, per_page=10, prefix="tz")
        await cb.message.edit_reply_markup(reply_markup=kb)
        await cb.answer(); return

    if payload == "tz:__next__":
        page = page + 1
        await state.update_data(page=page)
        kb = paginated_kb([(str(i), n) for i, n in enumerate(names)], page=page, per_page=10, prefix="tz")
        await cb.message.edit_reply_markup(reply_markup=kb)
        await cb.answer(); return

    if payload.startswith("tz:"):
        idx = int(payload.split(":", 1)[1])
        if not (0 <= idx < len(names)):
            await cb.answer("–•–∏–±–Ω–∏–π –≤–∏–±—ñ—Ä."); return
        sel = names[idx]
        await state.update_data(sel_teacher=sel)
        await cb.message.edit_text(f"–í–∏–±—Ä–∞–Ω–æ: {sel}\n–ù–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ—Å–∏–ª–∞–Ω–Ω—è Zoom –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.")
        await state.set_state(ZoomAdd.link)
        await cb.answer()

@router.message(ZoomAdd.link)
async def addzoom_save(message: Message, state: FSMContext):
    url = (message.text or "").strip()
    data = await state.get_data()
    sel = data.get("sel_teacher")

    if not (url.startswith("http://") or url.startswith("https://")):
        await message.answer("–¶–µ –Ω–µ —Å—Ö–æ–∂–µ –Ω–∞ URL. –ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ—Ä–º–∞–ª—å–Ω–∏–π –ª—ñ–Ω–∫, –±—É–¥—å –ª–∞—Å–∫–∞.")
        return

    sm = get_sessionmaker()
    async with sm() as s:
        await set_zoom_link(s, sel, url)
        await s.commit()

    await message.answer(f"–ó–±–µ—Ä–µ–∂–µ–Ω–æ Zoom –¥–ª—è ¬´{sel}¬ª:\n{url}")
    await state.clear()
